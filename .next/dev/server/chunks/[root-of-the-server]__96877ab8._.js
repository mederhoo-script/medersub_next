module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[project]/lib/supabase-admin.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "supabaseAdmin",
    ()=>supabaseAdmin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
;
const supabaseUrl = ("TURBOPACK compile-time value", "https://arbagxcbwqmquydrowjw.supabase.co");
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabaseAdmin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseServiceKey);
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/http2 [external] (http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[project]/lib/inlomax.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "inlomax",
    ()=>inlomax
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
;
const INLOMAX_API_KEY = process.env.INLOMAX_API_KEY;
const BASE_URL = 'https://inlomax.com/api';
const api = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].create({
    baseURL: BASE_URL,
    headers: {
        'Authorization': `Token ${INLOMAX_API_KEY}`,
        'Content-Type': 'application/json'
    }
});
const inlomax = {
    getBalance: async ()=>{
        try {
            const { data } = await api.get('/balance');
            return data;
        } catch (error) {
            console.error('Inlomax Balance Error:', error.response?.data || error.message);
            return {
                status: 'error',
                message: 'Failed to fetch balance'
            };
        }
    },
    getServices: async ()=>{
        try {
            const { data } = await api.get('/services');
            return data;
        } catch (error) {
            console.error('Inlomax Services Error:', error.response?.data || error.message);
            return {
                status: 'error',
                message: 'Failed to fetch services'
            };
        }
    },
    purchaseAirtime: async (mobileNumber, amount, serviceID)=>{
        try {
            const { data } = await api.post('/airtime', {
                mobileNumber,
                amount,
                serviceID
            });
            return data;
        } catch (error) {
            console.error('Inlomax Airtime Error:', error.response?.data || error.message);
            // Return the error response properly
            return error.response?.data || {
                status: 'error',
                message: 'Failed to purchase airtime'
            };
        }
    },
    purchaseData: async (mobileNumber, serviceID)=>{
        try {
            const { data } = await api.post('/data', {
                mobileNumber,
                serviceID
            });
            return data;
        } catch (error) {
            console.error('Inlomax Data Error:', error.response?.data || error.message);
            return error.response?.data || {
                status: 'error',
                message: 'Failed to purchase data'
            };
        }
    },
    validateCable: async (iucNum, serviceID)=>{
        try {
            const { data } = await api.post('/validatecable', {
                iucNum,
                serviceID
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to validate cable'
            };
        }
    },
    purchaseCable: async (iucNum, serviceID)=>{
        try {
            const { data } = await api.post('/subcable', {
                iucNum,
                serviceID
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to subscribe cable'
            };
        }
    },
    validateMeter: async (meterNum, serviceID, meterType)=>{
        try {
            const { data } = await api.post('/validatemeter', {
                meterNum,
                serviceID,
                meterType
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to validate meter'
            };
        }
    },
    payElectricity: async (meterNum, serviceID, meterType, amount)=>{
        try {
            const { data } = await api.post('/payelectric', {
                meterNum,
                serviceID,
                meterType,
                amount
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to pay electricity'
            };
        }
    },
    getTransaction: async (reference)=>{
        try {
            const { data } = await api.post('/transaction', {
                reference
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to fetch transaction'
            };
        }
    },
    purchaseEducation: async (serviceID, quantity)=>{
        try {
            const { data } = await api.post('/education', {
                serviceID,
                quantity
            });
            return data;
        } catch (error) {
            console.error('Inlomax Education Error:', error.response?.data || error.message);
            return error.response?.data || {
                status: 'error',
                message: 'Failed to purchase education pins'
            };
        }
    }
};
}),
"[project]/utils/pricing.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "calculateDataProfit",
    ()=>calculateDataProfit
]);
function calculateDataProfit(planName) {
    // Normalize string: remove spaces, lowercase
    const name = planName.toLowerCase().replace(/\s/g, '');
    // Extract number and unit
    const match = name.match(/(\d+(?:\.\d+)?)(mb|gb|tb)/);
    if (!match) return 0; // Default if parsing fails
    const value = parseFloat(match[1]);
    const unit = match[2];
    // Convert to GB for standardized comparison
    let sizeInGB = value;
    if (unit === 'mb') {
        sizeInGB = value / 1024;
    } else if (unit === 'tb') {
        sizeInGB = value * 1024;
    }
    // Pricing tiers logic
    if (sizeInGB <= 1) {
        return 10;
    } else if (sizeInGB <= 3) {
        return 20;
    } else if (sizeInGB <= 5) {
        return 30;
    } else if (sizeInGB <= 10) {
        return 50;
    } else {
        return 100; // > 10GB
    }
}
}),
"[project]/app/api/purchase/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
// Force rebuild
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase-admin.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/inlomax.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$utils$2f$pricing$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/utils/pricing.ts [app-route] (ecmascript)");
;
;
;
;
async function POST(req) {
    try {
        const body = await req.json();
        const { userId, serviceType, amount, mobileNumber, serviceID, network, planName, meterType, quantity } = body;
        console.log('Purchase Request:', {
            userId,
            serviceType,
            amount,
            mobileNumber,
            planName
        });
        // Validate required fields (mobileNumber not required for EDUCATION)
        if (!userId || !amount || !serviceID) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing required fields'
            }, {
                status: 400
            });
        }
        if (serviceType !== 'EDUCATION' && !mobileNumber) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Mobile number is required'
            }, {
                status: 400
            });
        }
        // 0. Check for Maintenance Mode & Markup
        const { data: settings } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('system_settings').select('*');
        const config = settings?.reduce((acc, curr)=>{
            acc[curr.key] = curr.value;
            return acc;
        }, {}) || {};
        const generalConfig = config.general || {};
        if (generalConfig.maintenance) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'System is currently under maintenance. Please try again later.'
            }, {
                status: 503
            });
        }
        // ... existing serviceKey logic ...
        let markupToApply = 0;
        let discount = 0;
        if (serviceType === 'DATA' && planName) {
            markupToApply = (0, __TURBOPACK__imported__module__$5b$project$5d2f$utils$2f$pricing$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculateDataProfit"])(planName);
        } else if (serviceType === 'AIRTIME') {
            // Apply Discount for Airtime
            const purchaseAmount = Number(amount);
            if (network === 'MTN' || network === 'AIRTEL') {
                discount = purchaseAmount * 0.01; // 1%
            } else {
                discount = purchaseAmount * 0.02; // 2%
            }
        } else if (serviceType === 'CABLE') {
            // DB markup for CABLE could be added here if needed, or specific logic.
            // For now, assume markup/discount logic is similar to others or standard DB config
            const globalMarkup = Number(generalConfig.markup || 0);
            markupToApply = globalMarkup;
        } else if (serviceType === 'ELECTRICITY') {
            // Apply Discount for Electricity (0.5%)
            const purchaseAmount = Number(amount);
            discount = purchaseAmount * 0.005;
        } else if (serviceType === 'EDUCATION') {
            // Apply ₦20 profit per pin
            const qty = Number(quantity || 1);
            markupToApply = 20 * qty;
        } else {
            // Fallback to DB markup for other services
            const globalMarkup = Number(generalConfig.markup || 0);
            markupToApply = globalMarkup;
        }
        // Calculate total cost to user 
        // For Airtime: Charged = Amount - Discount
        // For Data/Others: Charged = Amount + Markup
        const totalCharge = Number(amount) + markupToApply - discount;
        // 1. Check User Balance from WALLETS table
        const { data: wallet, error: walletError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('wallets').select('balance').eq('user_id', userId).single();
        if (walletError || !wallet) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'User wallet not found.'
            }, {
                status: 404
            });
        }
        if (Number(wallet.balance) < totalCharge) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: `Insufficient balance. Required: ₦${totalCharge}`
            }, {
                status: 400
            });
        }
        // 2. Call Inlomax API (Send the actual cost to provider, not the charged amount)
        let apiResponse;
        if (serviceType === 'AIRTIME') {
            apiResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlomax"].purchaseAirtime(mobileNumber, amount, serviceID);
        } else if (serviceType === 'DATA') {
            apiResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlomax"].purchaseData(mobileNumber, serviceID);
        } else if (serviceType === 'CABLE') {
            // "mobileNumber" here will act as "iucNum" for Cable
            apiResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlomax"].purchaseCable(mobileNumber, serviceID);
        } else if (serviceType === 'ELECTRICITY') {
            // "mobileNumber" is meterNum
            const mType = meterType || 1; // Default to 1 (Prepaid) if missing
            apiResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlomax"].payElectricity(mobileNumber, serviceID, mType, Number(amount));
        } else if (serviceType === 'EDUCATION') {
            const qty = Number(quantity || 1);
            apiResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlomax"].purchaseEducation(serviceID, qty);
        } else {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Invalid service type'
            }, {
                status: 400
            });
        }
        if (apiResponse.status !== 'success') {
            console.error('Provider API Failed:', apiResponse); // Log full response
            let errorMsg = apiResponse.message || 'Provider failed';
            const lowerMsg = errorMsg.toLowerCase();
            // Masking provider empty wallet error
            if (lowerMsg.includes('insufficient funds') || lowerMsg.includes('insuffucient funds')) {
                errorMsg = 'Service temporarily unavailable. Please try again later.';
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: errorMsg,
                debug: apiResponse
            }, {
                status: 502
            });
        }
        // 3. Deduct Total Charge from WALLETS
        const newBalance = Number(wallet.balance) - totalCharge;
        const { error: updateError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('wallets').update({
            balance: newBalance
        }).eq('user_id', userId);
        if (updateError) {
            console.error('CRITICAL: Failed to deduct balance', userId, totalCharge, updateError);
        }
        // 4. Record Transaction
        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('transactions').insert({
            user_id: userId,
            type: 'purchase',
            service_id: serviceID,
            amount: Number(amount),
            charged_amount: totalCharge,
            status: 'success',
            reference: apiResponse.data?.reference || `REF-${Date.now()}`,
            meta: {
                service_type: serviceType,
                mobile: mobileNumber,
                network: network,
                provider_ref: apiResponse.data?.reference,
                markup_applied: markupToApply,
                profit: markupToApply,
                ...serviceType === 'EDUCATION' && apiResponse.data?.pins ? {
                    pins: apiResponse.data.pins
                } : {}
            }
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            newBalance,
            message: apiResponse.message,
            ...serviceType === 'EDUCATION' && apiResponse.data?.pins ? {
                pins: apiResponse.data.pins
            } : {}
        });
    } catch (err) {
        console.error('Purchase API Exception:', err);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: err.message || 'Internal Server Error'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__96877ab8._.js.map