module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[project]/lib/supabase-admin.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "supabaseAdmin",
    ()=>supabaseAdmin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
;
const supabaseUrl = ("TURBOPACK compile-time value", "https://arbagxcbwqmquydrowjw.supabase.co");
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabaseAdmin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseServiceKey);
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/http2 [external] (http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[project]/lib/inlomax.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "inlomax",
    ()=>inlomax
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
;
const INLOMAX_API_KEY = process.env.INLOMAX_API_KEY;
const BASE_URL = 'https://inlomax.com/api';
const api = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].create({
    baseURL: BASE_URL,
    headers: {
        'Authorization': `Token ${INLOMAX_API_KEY}`,
        'Content-Type': 'application/json'
    }
});
const inlomax = {
    getBalance: async ()=>{
        try {
            const { data } = await api.get('/balance');
            return data;
        } catch (error) {
            console.error('Inlomax Balance Error:', error.response?.data || error.message);
            return {
                status: 'error',
                message: 'Failed to fetch balance'
            };
        }
    },
    getServices: async ()=>{
        try {
            const { data } = await api.get('/services');
            return data;
        } catch (error) {
            console.error('Inlomax Services Error:', error.response?.data || error.message);
            return {
                status: 'error',
                message: 'Failed to fetch services'
            };
        }
    },
    purchaseAirtime: async (mobileNumber, amount, serviceID)=>{
        try {
            const { data } = await api.post('/airtime', {
                mobileNumber,
                amount,
                serviceID
            });
            return data;
        } catch (error) {
            console.error('Inlomax Airtime Error:', error.response?.data || error.message);
            // Return the error response properly
            return error.response?.data || {
                status: 'error',
                message: 'Failed to purchase airtime'
            };
        }
    },
    purchaseData: async (mobileNumber, serviceID)=>{
        try {
            const { data } = await api.post('/data', {
                mobileNumber,
                serviceID
            });
            return data;
        } catch (error) {
            console.error('Inlomax Data Error:', error.response?.data || error.message);
            return error.response?.data || {
                status: 'error',
                message: 'Failed to purchase data'
            };
        }
    },
    validateCable: async (iucNum, serviceID)=>{
        try {
            const { data } = await api.post('/validatecable', {
                iucNum,
                serviceID
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to validate cable'
            };
        }
    },
    purchaseCable: async (iucNum, serviceID)=>{
        try {
            const { data } = await api.post('/subcable', {
                iucNum,
                serviceID
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to subscribe cable'
            };
        }
    },
    validateMeter: async (meterNum, serviceID, meterType)=>{
        try {
            const { data } = await api.post('/validatemeter', {
                meterNum,
                serviceID,
                meterType
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to validate meter'
            };
        }
    },
    payElectricity: async (meterNum, serviceID, meterType, amount)=>{
        try {
            const { data } = await api.post('/payelectric', {
                meterNum,
                serviceID,
                meterType,
                amount
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to pay electricity'
            };
        }
    },
    getTransaction: async (reference)=>{
        try {
            const { data } = await api.post('/transaction', {
                reference
            });
            return data;
        } catch (error) {
            return error.response?.data || {
                status: 'error',
                message: 'Failed to fetch transaction'
            };
        }
    }
};
}),
"[project]/app/api/purchase/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase-admin.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/inlomax.ts [app-route] (ecmascript)");
;
;
;
async function POST(req) {
    try {
        const body = await req.json();
        const { userId, serviceType, amount, mobileNumber, serviceID, network } = body;
        console.log('Purchase Request:', {
            userId,
            serviceType,
            amount,
            mobileNumber
        });
        if (!userId || !amount || !mobileNumber || !serviceID) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing required fields'
            }, {
                status: 400
            });
        }
        // 0. Check for Maintenance Mode & Markup
        const { data: settings } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('system_settings').select('*');
        const config = settings?.reduce((acc, curr)=>{
            acc[curr.key] = curr.value;
            return acc;
        }, {}) || {};
        const generalConfig = config.general || {};
        if (generalConfig.maintenance) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'System is currently under maintenance. Please try again later.'
            }, {
                status: 503
            });
        }
        // Fetch Service-Specific Configuration
        // We assume 'serviceID' for data is roughly mapped to our services table or we use 'network-type' combo
        // For simplicity, we check if there's a markup for the 'type' keys we seeded: 'mtn-data', 'glo-airtime' etc.
        // Construct a likely ID based on input.
        // network is like 'MTN', 'GLO'. serviceType is 'DATA', 'AIRTIME'.
        // ID format in DB: lowercase(network)-lowercase(serviceType) -> 'mtn-data'
        let serviceKey = '';
        if (network && serviceType) {
            serviceKey = `${network.toLowerCase()}-${serviceType.toLowerCase()}`;
        }
        let specificMarkup = 0;
        let serviceIsActive = true;
        if (serviceKey) {
            const { data: serviceConfig } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('services').select('markup, is_active').eq('id', serviceKey).single();
            if (serviceConfig) {
                if (serviceConfig.is_active === false) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        error: 'This service is currently disabled.'
                    }, {
                        status: 503
                    });
                }
                specificMarkup = Number(serviceConfig.markup || 0);
            }
        }
        // Markup Logic: Use Specific if > 0, else use Global
        // Or should specific ADDS to global? Usually specific OVERRIDES global.
        // Let's go with: If specific markup is set (even 0), use it?
        // Or if specific row exists, use it.
        // Our seeded data has defaults. Let's say if specificMarkup is found, use it.
        // But what if they want 0 markup?
        // Let's assume global markup is fallback if service not found in DB.
        const globalMarkup = Number(generalConfig.markup || 0);
        const finalMarkup = specificMarkup > 0 ? specificMarkup : globalMarkup; // Simple logic: if specific is set, use it.
        // Wait, if specific is 0, do we fallback?
        // Better: if serviceConfig existed, use its markup (even if 0).
        // If serviceConfig didn't exist, use global.
        const markupToApply = serviceKey && specificMarkup !== undefined ? specificMarkup : globalMarkup;
        // Calculate total cost to user (Provider Amount + Markup)
        // Ensure 'amount' passed from frontend is the BASE amount or TOTAL?
        // Usually, frontend shows Plan Price. We should charge Plan Price + Markup?
        // Or is Plan Price already including Markup?
        // Let's assume 'amount' is what the user expects to pay (Plan Price).
        // If we want to add a fee ON TOP, we do it here.
        // For simplicity: Charged Amount = Amount + Markup.
        const totalCharge = Number(amount) + markupToApply;
        // 1. Check User Balance from WALLETS table
        const { data: wallet, error: walletError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('wallets').select('balance').eq('user_id', userId).single();
        if (walletError || !wallet) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'User wallet not found.'
            }, {
                status: 404
            });
        }
        if (Number(wallet.balance) < totalCharge) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: `Insufficient balance. Required: â‚¦${totalCharge}`
            }, {
                status: 400
            });
        }
        // 2. Call Inlomax API (Send the actual cost to provider, not the charged amount)
        let apiResponse;
        if (serviceType === 'AIRTIME') {
            apiResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlomax"].purchaseAirtime(mobileNumber, amount, serviceID);
        } else if (serviceType === 'DATA') {
            apiResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$inlomax$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inlomax"].purchaseData(mobileNumber, serviceID);
        } else {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Invalid service type'
            }, {
                status: 400
            });
        }
        if (apiResponse.status !== 'success') {
            console.error('Provider API Failed:', apiResponse); // Log full response
            let errorMsg = apiResponse.message || 'Provider failed';
            const lowerMsg = errorMsg.toLowerCase();
            // Masking provider empty wallet error
            if (lowerMsg.includes('insufficient funds') || lowerMsg.includes('insuffucient funds')) {
                errorMsg = 'Service temporarily unavailable. Please try again later.';
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: errorMsg,
                debug: apiResponse
            }, {
                status: 502
            });
        }
        // 3. Deduct Total Charge from WALLETS
        const newBalance = Number(wallet.balance) - totalCharge;
        const { error: updateError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('wallets').update({
            balance: newBalance
        }).eq('user_id', userId);
        if (updateError) {
            console.error('CRITICAL: Failed to deduct balance', userId, totalCharge, updateError);
        }
        // 4. Record Transaction
        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('transactions').insert({
            user_id: userId,
            type: 'purchase',
            service_id: serviceID,
            amount: Number(amount),
            charged_amount: totalCharge,
            status: 'success',
            reference: apiResponse.data?.reference || `REF-${Date.now()}`,
            meta: {
                service_type: serviceType,
                mobile: mobileNumber,
                network: network,
                provider_ref: apiResponse.data?.reference,
                markup_applied: markupToApply,
                profit: markupToApply
            }
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            newBalance,
            message: apiResponse.message
        });
    } catch (err) {
        console.error('Purchase API Exception:', err);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: err.message || 'Internal Server Error'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__2ce152d9._.js.map